<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>양자컴퓨터가 바꿀 미래의 계산 | LabWave</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <!-- 배경(별/그라디언트) -->
  <div class="bg" aria-hidden="true">
    <div class="stars"></div>
    <div class="stars stars2"></div>
    <div class="glow"></div>
  </div>

  <!-- 상단바(간단) -->
  <header class="navbar">
    <div class="container nav-inner">
      <a class="brand" href="index.html">
        <div class="brand-mark">L</div>
        <div class="brand-name">LabWave</div>
      </a>

      <div class="nav-actions">
        <a class="btn btn-ghost btn-sm" href="index.html#content">← 돌아가기</a>
      </div>
    </div>
  </header>

  <main class="section">
    <div class="container">
      <!-- 칼럼 헤더 -->
      <div class="article-head">
        <span class="section-pill">Hot Topic</span>
        <h1 class="article-title">양자컴퓨터가 바꿀 미래의 계산</h1>
        <p class="article-sub">
          기존 컴퓨터의 한계를 넘는 계산 방식이 등장한다면, 과학과 산업은 어떻게 달라질까요?
        </p>

        <div class="article-meta">
          <span>작성: LabWave Demo</span>
          <span>읽는 시간: 3분</span>
        </div>
      </div>

      <!-- 칼럼 본문 -->
      <article class="article-card">
        <h2>1) 왜 ‘양자’가 게임 체인저인가</h2>
        <p>
          일반 컴퓨터는 0 또는 1로 정보를 처리해요. 반면, 양자컴퓨터는 ‘겹침(중첩)’ 같은 양자 특성을 활용해
          여러 경우의 수를 동시에 탐색할 수 있어요. 그래서 특정 문제(예: 최적화, 시뮬레이션)에서는 엄청난 속도 향상이 기대됩니다.
        </p>

        <h2>2) 무엇이 바뀔까</h2>
        <ul>
          <li><b>신약 개발</b>: 분자 수준의 시뮬레이션이 더 정교해질 수 있어요.</li>
          <li><b>소재/배터리</b>: 새로운 소재를 찾는 탐색이 빨라질 수 있어요.</li>
          <li><b>물류/금융</b>: 최적화 문제가 많은 분야에서 효율이 크게 오를 수 있어요.</li>
        </ul>

        <h2>3) 아직 남은 과제</h2>
        <p>
          현실에서는 오류(노이즈) 문제가 크고, 안정적으로 큰 규모로 확장하는 것도 어렵습니다.
          그래서 당분간은 “특정 문제에 강한 양자 + 기존 컴퓨터”가 함께 쓰이는 형태가 현실적이에요.
        </p>

        <div class="article-cta">
          <a class="btn btn-primary" href="#comments">이 주제에 의견 남기기</a>
          <a class="btn btn-ghost" href="index.html#content">다른 토픽 보기</a>
        </div>
      </article>

      <!-- 댓글/대댓글 -->
      <section id="comments" class="comment-section">
        <div class="comment-head">
          <h2 class="comment-title">댓글</h2>
          <p class="comment-sub">이 페이지에서 작성한 댓글은 데모용으로 이 브라우저에 저장됩니다.</p>
        </div>

        <!-- 새 댓글 작성 -->
        <form id="newCommentForm" class="comment-form">
          <div class="form-row">
            <label class="label">닉네임</label>
            <input id="authorInput" class="input" maxlength="20" placeholder="예) jiwoody" required />
          </div>

          <div class="form-row">
            <label class="label">내용</label>
            <textarea id="contentInput" class="textarea" maxlength="300" placeholder="의견을 남겨주세요 (최대 300자)" required></textarea>
          </div>

          <div class="form-actions">
            <button class="btn btn-primary" type="submit">댓글 등록</button>
            <button class="btn btn-ghost" type="button" id="resetBtn">초기화</button>
          </div>
        </form>

        <!-- 댓글 리스트 -->
        <div id="commentList" class="comment-list"></div>
      </section>
    </div>
  </main>

  <script>
    // ====== Demo Comment System (localStorage) ======
    // 페이지별로 댓글을 분리 저장
    const STORAGE_KEY = "labwave_comments_topic_quantum_v1";

    const $ = (sel) => document.querySelector(sel);
    const commentListEl = $("#commentList");
    const newCommentForm = $("#newCommentForm");
    const authorInput = $("#authorInput");
    const contentInput = $("#contentInput");
    const resetBtn = $("#resetBtn");

    function nowISO() {
      return new Date().toISOString();
    }

    function uid() {
      return Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
    }

    function loadComments() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch {
        return [];
      }
    }

    function saveComments(comments) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(comments));
    }

    // 댓글 구조:
    // { id, parentId: null|id, author, content, createdAt }
    function addComment({ parentId = null, author, content }) {
      const comments = loadComments();
      comments.push({
        id: uid(),
        parentId,
        author: author.trim(),
        content: content.trim(),
        createdAt: nowISO(),
      });
      saveComments(comments);
      render();
    }

    function formatTime(iso) {
      const d = new Date(iso);
      const yy = String(d.getFullYear()).slice(2);
      const mm = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      const hh = String(d.getHours()).padStart(2,"0");
      const mi = String(d.getMinutes()).padStart(2,"0");
      return `${yy}.${mm}.${dd} ${hh}:${mi}`;
    }

    function buildTree(comments) {
      const map = new Map();
      comments.forEach(c => map.set(c.id, { ...c, children: [] }));
      const roots = [];
      map.forEach(node => {
        if (node.parentId && map.has(node.parentId)) {
          map.get(node.parentId).children.push(node);
        } else {
          roots.push(node);
        }
      });
      // 시간순 정렬
      const sortByTime = (a,b) => new Date(a.createdAt) - new Date(b.createdAt);
      const deepSort = (nodes) => {
        nodes.sort(sortByTime);
        nodes.forEach(n => deepSort(n.children));
      };
      deepSort(roots);
      return roots;
    }

    function escapeHtml(str) {
      return str
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function render() {
      const comments = loadComments();
      if (comments.length === 0) {
        commentListEl.innerHTML = `<div class="comment-empty">아직 댓글이 없어요. 첫 댓글을 남겨보세요!</div>`;
        return;
      }

      const tree = buildTree(comments);

      function renderNode(node, depth) {
        const indentClass = depth === 0 ? "cmt" : "cmt cmt-reply";
        const safeAuthor = escapeHtml(node.author);
        const safeContent = escapeHtml(node.content).replaceAll("\n","<br/>");
        const time = formatTime(node.createdAt);

        const replyBoxId = `replyBox-${node.id}`;
        const replyFormId = `replyForm-${node.id}`;
        const replyAuthorId = `replyAuthor-${node.id}`;
        const replyContentId = `replyContent-${node.id}`;

        return `
          <div class="${indentClass}">
            <div class="cmt-top">
              <div class="cmt-author">${safeAuthor}</div>
              <div class="cmt-time">${time}</div>
            </div>
            <div class="cmt-content">${safeContent}</div>
            <div class="cmt-actions">
              <button class="cmt-btn" data-action="toggle-reply" data-id="${node.id}">답글</button>
            </div>

            <div class="reply-box" id="${replyBoxId}" hidden>
              <form class="reply-form" id="${replyFormId}" data-parent="${node.id}">
                <div class="reply-row">
                  <input class="input" id="${replyAuthorId}" maxlength="20" placeholder="닉네임" required />
                </div>
                <div class="reply-row">
                  <textarea class="textarea" id="${replyContentId}" maxlength="300" placeholder="대댓글 내용 (최대 300자)" required></textarea>
                </div>
                <div class="reply-actions">
                  <button class="btn btn-primary btn-sm" type="submit">대댓글 등록</button>
                  <button class="btn btn-ghost btn-sm" type="button" data-action="cancel-reply" data-id="${node.id}">취소</button>
                </div>
              </form>
            </div>

            ${node.children.map(ch => renderNode(ch, depth+1)).join("")}
          </div>
        `;
      }

      commentListEl.innerHTML = tree.map(n => renderNode(n, 0)).join("");

      // 이벤트 연결(토글/취소)
      commentListEl.querySelectorAll("[data-action='toggle-reply']").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.dataset.id;
          const box = document.getElementById(`replyBox-${id}`);
          box.hidden = !box.hidden;
        });
      });

      commentListEl.querySelectorAll("[data-action='cancel-reply']").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.dataset.id;
          const box = document.getElementById(`replyBox-${id}`);
          box.hidden = true;
        });
      });

      // 대댓글 submit
      commentListEl.querySelectorAll(".reply-form").forEach(form => {
        form.addEventListener("submit", (e) => {
          e.preventDefault();
          const parentId = form.dataset.parent;
          const a = form.querySelector("input").value.trim();
          const c = form.querySelector("textarea").value.trim();
          if (!a || !c) return;
          addComment({ parentId, author: a, content: c });
        });
      });
    }

    // 새 댓글 등록
    newCommentForm.addEventListener("submit", (e) => {
      e.preventDefault();
      addComment({ author: authorInput.value, content: contentInput.value });
      authorInput.value = "";
      contentInput.value = "";
    });

    resetBtn.addEventListener("click", () => {
      authorInput.value = "";
      contentInput.value = "";
      authorInput.focus();
    });

    // 최초 렌더
    render();
  </script>
</body>
</html>
