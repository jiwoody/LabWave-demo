<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>양자컴퓨터가 바꿀 미래의 계산 | LabWave</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <!-- 배경(별/그라디언트) -->
  <div class="bg" aria-hidden="true">
    <div class="stars"></div>
    <div class="stars stars2"></div>
    <div class="glow"></div>
  </div>

  <!-- 상단바(간단) -->
  <header class="navbar">
    <div class="container nav-inner">
      <a class="brand" href="index.html">
        <div class="brand-mark">L</div>
        <div class="brand-name">LabWave</div>
      </a>

      <div class="nav-actions">
        <a class="btn btn-ghost btn-sm" href="index.html#content">← 돌아가기</a>
      </div>
    </div>
  </header>

  <main class="section">
    <div class="container">
      <!-- 칼럼 헤더 -->
      <div class="article-head">
        <span class="section-pill">Hot Topic</span>
        <h1 class="article-title">양자컴퓨터가 바꿀 미래의 계산</h1>
        <p class="article-sub">
          기존 컴퓨터의 한계를 넘는 계산 방식이 등장한다면, 과학과 산업은 어떻게 달라질까요?
        </p>

        <div class="article-meta">
          <span>작성: LabWave Demo</span>
          <span>읽는 시간: 3분</span>
        </div>
      </div>

      <!-- 칼럼 본문 -->
      <article class="article-card">
        <h2>1) 왜 ‘양자’가 게임 체인저인가</h2>
        <p>
          일반 컴퓨터는 0 또는 1로 정보를 처리해요. 반면, 양자컴퓨터는 ‘겹침(중첩)’ 같은 양자 특성을 활용해
          여러 경우의 수를 동시에 탐색할 수 있어요. 그래서 특정 문제(예: 최적화, 시뮬레이션)에서는 엄청난 속도 향상이 기대됩니다.
        </p>

        <h2>2) 무엇이 바뀔까</h2>
        <ul>
          <li><b>신약 개발</b>: 분자 수준의 시뮬레이션이 더 정교해질 수 있어요.</li>
          <li><b>소재/배터리</b>: 새로운 소재를 찾는 탐색이 빨라질 수 있어요.</li>
          <li><b>물류/금융</b>: 최적화 문제가 많은 분야에서 효율이 크게 오를 수 있어요.</li>
        </ul>

        <h2>3) 아직 남은 과제</h2>
        <p>
          현실에서는 오류(노이즈) 문제가 크고, 안정적으로 큰 규모로 확장하는 것도 어렵습니다.
          그래서 당분간은 “특정 문제에 강한 양자 + 기존 컴퓨터”가 함께 쓰이는 형태가 현실적이에요.
        </p>

        <div class="article-cta">
          <a class="btn btn-primary" href="#comments">이 주제에 의견 남기기</a>
          <a class="btn btn-ghost" href="index.html#content">다른 토픽 보기</a>
        </div>
      </article>

      <!-- 댓글/대댓글 -->
      <section id="comments" class="comment-section">
        <div class="comment-head">
          <h2 class="comment-title">댓글</h2>
          <p class="comment-sub">이 페이지의 댓글은 모든 방문자에게 공유됩니다. (데모: 로그인 없이 닉네임)</p>
        </div>

        <!-- 새 댓글 작성 -->
        <form id="newCommentForm" class="comment-form">
          <div class="form-row">
            <label class="label">닉네임</label>
            <input id="authorInput" class="input" maxlength="20" placeholder="예) jiwoody" required />
          </div>

          <div class="form-row">
            <label class="label">내용</label>
            <textarea id="contentInput" class="textarea" maxlength="300" placeholder="의견을 남겨주세요 (최대 300자)" required></textarea>
          </div>

          <div class="form-actions">
            <button class="btn btn-primary" type="submit">댓글 등록</button>
            <button class="btn btn-ghost" type="button" id="resetBtn">초기화</button>
          </div>
        </form>

        <!-- 댓글 리스트 -->
        <div id="commentList" class="comment-list"></div>
      </section>
    </div>
  </main>

  <!-- ✅ Supabase 공유 댓글/대댓글 스크립트 -->
  <script type="module">
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

    // ==========================
    // 1) 여기 2줄만 네 값으로 교체
    // ==========================
    const SUPABASE_URL = "https://YOUR_PROJECT.supabase.co";
    const SUPABASE_KEY = "YOUR_PUBLISHABLE_KEY";

    const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

    // 페이지(글) 식별자: 다른 글은 slug만 바꾸면 댓글이 분리됨
    const PAGE_SLUG = "topic-quantum";

    const $ = (sel) => document.querySelector(sel);
    const commentListEl = $("#commentList");
    const newCommentForm = $("#newCommentForm");
    const authorInput = $("#authorInput");
    const contentInput = $("#contentInput");
    const resetBtn = $("#resetBtn");

    // ===== 유틸 =====
    function escapeHtml(str) {
      return (str ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function formatTime(iso) {
      const d = new Date(iso);
      const yy = String(d.getFullYear()).slice(2);
      const mm = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      const hh = String(d.getHours()).padStart(2,"0");
      const mi = String(d.getMinutes()).padStart(2,"0");
      return `${yy}.${mm}.${dd} ${hh}:${mi}`;
    }

    // ===== Supabase I/O =====
    async function fetchComments() {
      const { data, error } = await supabase
        .from("comments")
        .select("id,page_slug,parent_id,author,content,created_at")
        .eq("page_slug", PAGE_SLUG)
        .order("created_at", { ascending: true });

      if (error) {
        commentListEl.innerHTML = `<div class="comment-empty">댓글을 불러오지 못했어요: ${escapeHtml(error.message)}</div>`;
        return [];
      }
      return data ?? [];
    }

    async function insertComment({ parent_id = null, author, content }) {
      author = (author ?? "").trim().slice(0, 20);
      content = (content ?? "").trim().slice(0, 300);

      if (!author || !content) return;

      const { error } = await supabase.from("comments").insert({
        page_slug: PAGE_SLUG,
        parent_id,
        author,
        content,
      });

      if (error) {
        alert("등록 실패: " + error.message);
        return;
      }
      await render();
    }

    // ===== 트리 구성 =====
    function buildTree(rows) {
      const map = new Map();
      rows.forEach(r => map.set(r.id, { ...r, children: [] }));

      const roots = [];
      map.forEach(node => {
        if (node.parent_id && map.has(node.parent_id)) {
          map.get(node.parent_id).children.push(node);
        } else {
          roots.push(node);
        }
      });

      const sortByTime = (a,b) => new Date(a.created_at) - new Date(b.created_at);
      const deepSort = (nodes) => {
        nodes.sort(sortByTime);
        nodes.forEach(n => deepSort(n.children));
      };
      deepSort(roots);
      return roots;
    }

    // ===== 렌더 =====
    function renderTree(tree) {
      function renderNode(node, depth) {
        const indentClass = depth === 0 ? "cmt" : "cmt cmt-reply";
        const safeAuthor = escapeHtml(node.author);
        const safeContent = escapeHtml(node.content).replaceAll("\n","<br/>");
        const time = formatTime(node.created_at);

        return `
          <div class="${indentClass}">
            <div class="cmt-top">
              <div class="cmt-author">${safeAuthor}</div>
              <div class="cmt-time">${time}</div>
            </div>
            <div class="cmt-content">${safeContent}</div>
            <div class="cmt-actions">
              <button class="cmt-btn" data-action="toggle-reply" data-id="${node.id}">답글</button>
            </div>

            <div class="reply-box" id="replyBox-${node.id}" hidden>
              <form class="reply-form" data-parent="${node.id}">
                <div class="reply-row">
                  <input class="input" maxlength="20" placeholder="닉네임" required />
                </div>
                <div class="reply-row">
                  <textarea class="textarea" maxlength="300" placeholder="대댓글 내용 (최대 300자)" required></textarea>
                </div>
                <div class="reply-actions">
                  <button class="btn btn-primary btn-sm" type="submit">대댓글 등록</button>
                  <button class="btn btn-ghost btn-sm" type="button" data-action="cancel-reply" data-id="${node.id}">취소</button>
                </div>
              </form>
            </div>

            ${node.children.map(ch => renderNode(ch, depth+1)).join("")}
          </div>
        `;
      }

      return tree.map(n => renderNode(n, 0)).join("");
    }

    async function render() {
      commentListEl.innerHTML = `<div class="comment-empty">불러오는 중...</div>`;

      const rows = await fetchComments();
      if (!rows.length) {
        commentListEl.innerHTML = `<div class="comment-empty">아직 댓글이 없어요. 첫 댓글을 남겨보세요!</div>`;
        return;
      }

      const tree = buildTree(rows);
      commentListEl.innerHTML = renderTree(tree);

      // 답글 토글
      commentListEl.querySelectorAll("[data-action='toggle-reply']").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.dataset.id;
          const box = document.getElementById(`replyBox-${id}`);
          box.hidden = !box.hidden;
        });
      });

      // 답글 취소
      commentListEl.querySelectorAll("[data-action='cancel-reply']").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.dataset.id;
          const box = document.getElementById(`replyBox-${id}`);
          box.hidden = true;
        });
      });

      // 대댓글 등록
      commentListEl.querySelectorAll(".reply-form").forEach(form => {
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          const parent_id = form.dataset.parent;
          const author = form.querySelector("input").value;
          const content = form.querySelector("textarea").value;
          await insertComment({ parent_id, author, content });
        });
      });
    }

    // 새 댓글 등록
    newCommentForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      await insertComment({ author: authorInput.value, content: contentInput.value });
      authorInput.value = "";
      contentInput.value = "";
    });

    resetBtn.addEventListener("click", () => {
      authorInput.value = "";
      contentInput.value = "";
      authorInput.focus();
    });

    // 최초 렌더
    render();
  </script>
</body>
</html>
